#Q1: two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.
Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.
The tests are generated such that there is exactly one solution. You may not use the same element twice.
Your solution must use only constant extra space.
Example 1:
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].


Code:
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        # Two pointers approach
        left_pointer, right_pointer = 0, len(numbers) - 1  
        while left_pointer < right_pointer:
            pointers_sum = numbers[left_pointer] + numbers[right_pointer]
            if pointers_sum == target:
                return [left_pointer + 1, right_pointer + 1] #Convert to 1-based indexing
            elif pointers_sum < target:
                left_pointer += 1  # Move left pointer to increase sum
            else:
                right_pointer -= 1  # Move right pointer to decrease sum



#Q2:Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.
Example 1:
Input: nums = [1,2,3,4]
Output: [24,12,8,6]

Code:
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [1] * n  # Initialize result array with 1

        # First pass: Compute prefix product using pointer1
        pointer1 = 1
        for i in range(n):
            result[i] = pointer1
            pointer1 *= nums[i]  # Update pointer1 product

        # Second pass: Compute suffix product using pointer2 and multiply with      result
        pointer2 = 1
        for i in range(n - 1, -1, -1):
            result[i] *= pointer2
            pointer2 *= nums[i]  # Update pointer2 product

        return result
